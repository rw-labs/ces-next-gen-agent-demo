<!DOCTYPE html>
<html>
<head>
  <title>Next-Gen Agent Demo</title>
  <link rel="stylesheet" href="styles/style.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="assets/favicon.ico">
</head>
<body style="margin:0;padding:0;">
  <div style="display:flex;flex-direction:row;height:100vh;width:100vw;overflow:hidden;">
    <!-- Left: Agent UI (30%) -->
    <div id="agent-ui" style="width:30vw;min-width:320px;max-width:600px;height:100vh;overflow-y:auto;background:#fff;box-shadow:2px 0 8px rgba(0,0,0,0.04);z-index:2;">
      <div class="header-section">
        <h1><strong>Next-Gen Agent Prototype</strong></h1>
        <p style="font-size: 1.0;">Speak into your microphone and optionally share your webcam or screen to engage in a multimedia conversation.</p>
      </div>
      <div class="input-container">
        <button id="micButton" disabled class="action-button">
          <span class="material-symbols-outlined">mic</span>
        </button>
        <button id="webcamButton" class="action-button">
          <span class="material-symbols-outlined">videocam</span>
        </button>
        <button id="screenButton" class="action-button">
          <span class="material-symbols-outlined">present_to_all</span>
        </button>
        <button id="imageButton" class="action-button">
          <span class="material-symbols-outlined">image</span>
        </button>
        <input type="file" id="imageInput" accept="image/*" style="display: none;">
        <div class="text-input-container">
          <input type="text" id="textInput" placeholder="Type your message..." class="text-input">
          <button id="sendButton" class="action-button">
            <span class="material-symbols-outlined">send</span>
          </button>
          <button id="interruptButton" class="action-button" style="display: none;">
            <span class="material-symbols-outlined">cancel</span>
          </button>
          <button id="endSessionButton" class="action-button" title="End Session">
            <span class="material-symbols-outlined">stop_circle</span>
          </button>
        </div>
      </div>
      <div class="video-container">
        <video id="videoPreview" autoplay playsinline class="hidden"></video>
      </div>
      <div id="imagePreviewContainer" style="display: none;">
        <img id="imagePreview" src="" alt="Image Preview" style="max-width: 100%; max-height: 200px;">
      </div>
      <div id="output"></div>
    </div>
    <!-- Right: Dyson Homepage (70%) -->
    <div id="dyson-home" style="flex:1;height:100vh;overflow:auto;z-index:1;">
      <!-- Dyson content will be loaded here -->
    </div>
  </div>
  <!-- Load EventEmitter3 first -->
  <script src="https://cdn.jsdelivr.net/npm/eventemitter3@5.0.1/dist/eventemitter3.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify/dist/purify.min.js"></script>

  <script type="module">
    import { AudioRecorder } from './src/audio/audio-recorder.js';
    import { AudioStreamer } from './src/audio/audio-streamer.js';
    import { MediaHandler } from './src/media/media-handler.js';
    import { GeminiAPI } from './src/api/gemini-api.js';
    import { base64ToArrayBuffer } from './src/utils/utils.js';

    // Initialize components
    const output = document.getElementById('output');
    const audioRecorder = new AudioRecorder();
    const audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
    const audioStreamer = new AudioStreamer(audioContext);
    const mediaHandler = new MediaHandler();
    const api = new GeminiAPI('ws://localhost:8080/ws');

    let isRecording = false;
    let hasShownSpeakingMessage = false;
    let currentTurn = 0;
    let lastAudioTurn = -1;

    // Initialize media handler
    mediaHandler.initialize(document.getElementById('videoPreview'));

    // Set up API handlers
    api.onReady = () => {
      document.getElementById('micButton').disabled = false;
      // Add these lines to enable other controls:
      document.getElementById('webcamButton').disabled = false;
      document.getElementById('screenButton').disabled = false;
      document.getElementById('imageButton').disabled = false;
      document.getElementById('sendButton').disabled = false;
      document.getElementById('textInput').disabled = false;
      document.getElementById('endSessionButton').disabled = false; // Enable end button
      logMessage("System: Connected to server.");
    };

    api.onConfig = (configData) => {
      if (configData.use_tts) {
        logMessage(`System: Using Cloud TTS Voice: ${configData.voice}, Lang: ${configData.model_language}, Prompt: ${configData.prompt_language}`);
      } else {
        logMessage(`System: Using Live API Voice: ${configData.voice}, Lang: ${configData.model_language}, Prompt: ${configData.prompt_language}`);
      }
      
    };

    api.onClose = () => {
        logMessage("System: Disconnected from server.");
        // Disable controls on disconnect
        document.getElementById('micButton').disabled = true;
        document.getElementById('webcamButton').disabled = true;
        document.getElementById('screenButton').disabled = true;
        document.getElementById('imageButton').disabled = true;
        document.getElementById('sendButton').disabled = true;
        document.getElementById('textInput').disabled = true;
        document.getElementById('endSessionButton').disabled = true;
        document.getElementById('interruptButton').style.display = 'none';
        if (isRecording) {
            stopRecording(false); // Ensure recording stops if connection drops
        }
        mediaHandler.stopAll(); // Stop media streams
    };


    api.onAudioData = async (audioData) => {
      try {
        if (!api.isSpeaking || lastAudioTurn !== currentTurn) {
          logMessage('Gemini: Speaking...');
          api.isSpeaking = true;
          lastAudioTurn = currentTurn;
          document.getElementById('interruptButton').style.display = 'inline-block';
        }
        const arrayBuffer = base64ToArrayBuffer(audioData);
        audioStreamer.addPCM16(new Uint8Array(arrayBuffer));
        audioStreamer.resume();
      } catch (error) {
        console.error('Error playing audio:', error);
      }
    };

    api.onTextContent = (text) => {
      if (text.trim()) {
        logMessage('Gemini: ' + text);
      }
    };

    api.onTurnComplete = () => {
      logMessage('Gemini: Finished speaking');
      api.isSpeaking = false;  // Reset speaking state
      audioStreamer.complete();
      document.getElementById('interruptButton').style.display = 'none';
    };

    // Add interruption handler
    api.onInterrupted = (data) => {
      logMessage('Gemini: Response interrupted');
      api.isSpeaking = false;
      audioStreamer.stop();  // Stop current playback and clear queue
      document.getElementById('interruptButton').style.display = 'none';
      
      // Show visual feedback for interruption
      const messageElement = document.createElement('p');
      messageElement.className = 'interrupted-message';
      messageElement.textContent = 'Response interrupted by user input';
      output.appendChild(messageElement);
      output.scrollTop = output.scrollHeight;
    };

    // Add function call and response handlers
    api.onFunctionCall = (data) => {
      logMessage('Function: ' + data.name);
      logMessage('Parameters: ' + JSON.stringify(data.args, null, 2));
      if (data.name === 'show_hair_dryer_models') {
        fetch('dyson_supersonic.html')
          .then(response => response.text())
          .then(html => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const dysonBody = doc.body.innerHTML;
            document.getElementById('dyson-home').innerHTML = dysonBody;
          })
          .catch(err => {
            document.getElementById('dyson-home').innerHTML = '<p style="color:red;">Failed to load Dyson Supersonic content.</p>';
            console.error('Error loading Dyson Supersonic content:', err);
          });
      }
    };

    api.onFunctionResponse = (data) => {
      logMessage('API Response: ' + JSON.stringify(data, null, 2));
      // Check for appointment_id and show appointment.html if present
      if (data && data.appointment_id) {
        fetch('dyson_appointment.html')
          .then(response => response.text())
          .then(html => {
            document.getElementById('dyson-home').innerHTML = html;
            // Wait for DOM to update, then set the values
            setTimeout(() => {
              if (document.getElementById('appointmentId')) {
                document.getElementById('appointmentId').textContent = data.appointment_id;
              }
              if (document.getElementById('appointmentSlot')) {
                document.getElementById('appointmentSlot').textContent = data.scheduled_slot;
              }
            }, 0);
          })
          .catch(err => {
            document.getElementById('dyson-home').innerHTML = '<p style="color:red;">Failed to load Appointment content.</p>';
            console.error('Error loading Appointment content:', err);
          });
      } else if (data && data.video_url && data.video_url.includes('youtube.com')) {
        fetch('video.html')
          .then(response => response.text())
          .then(html => {
            document.getElementById('dyson-home').innerHTML = html;
            
            const videoUrl = new URL(data.video_url);
            const videoId = videoUrl.searchParams.get('v');

            if (videoId) {
              const embedUrl = `https://www.youtube.com/embed/${videoId}?autoplay=1&mute=1`; // Add autoplay and mute
              // Wait for DOM to update, then set the src
              setTimeout(() => {
                const iframe = document.getElementById('youtube-video');
                if (iframe) {
                  iframe.src = embedUrl;
                }
              }, 0);
            } else {
              console.error('Could not extract YouTube video ID from URL:', data.video_url);
              document.getElementById('dyson-home').innerHTML = '<p style="color:red;">Failed to get video ID from URL.</p>';
            }
          })
          .catch(err => {
            document.getElementById('dyson-home').innerHTML = '<p style="color:red;">Failed to load video player.</p>';
            console.error('Error loading video.html:', err);
          });
      }
    };

    api.onMessage = (message) => {
      if (typeof message === 'object' && message !== null) {
        logMessage(message);
      }
    };
    api.onError = (error) => { // Copied for completeness
        console.error("API Error:", error);
        logMessage(`System Error: ${error.message || JSON.stringify(error)}`);
    };


    // UI Event Handlers
    async function startRecording() {
      try {
        // If model is speaking, treat this as an interruption
        if (api.isSpeaking) {
          audioStreamer.stop();
          api.isSpeaking = false;
        }

        await audioContext.resume();
        await audioRecorder.start();
        hasShownSpeakingMessage = false;
        currentTurn++;
        
        audioRecorder.on('data', (base64Data) => {
          if (!hasShownSpeakingMessage) {
            logMessage('You: Speaking...');
            hasShownSpeakingMessage = true;
          }
          api.sendAudioChunk(base64Data);
        });

        isRecording = true;
        document.getElementById('micButton').innerHTML = 
          '<span class="material-symbols-outlined">stop</span>';
      } catch (error) {
        console.error('Error starting recording:', error);
        logMessage('Error: ' + error.message);
      }
    }

    function stopRecording(sendEndMsg = true) {
      if (!isRecording) return;
      audioRecorder.stop();
      isRecording = false;
      hasShownSpeakingMessage = false;
      document.getElementById('micButton').innerHTML =
        '<span class="material-symbols-outlined">mic</span>';
      logMessage('You: Recording stopped.');
      // Conditionally send the 'end' message
      if (sendEndMsg) { // Check sessionActive too
        api.sendEndMessage(); // Signal end of user turn
      }
      api.isSpeaking = false; // Ensure speaking flag is reset
      }

    function logMessage(message) {
      const messageElement = document.createElement('div');
      let handled = false;
      
      // Add specific styling based on message content
      if (typeof message === 'string'){
        if (message.startsWith('Function:')) {
          messageElement.className = 'function-name';
        } else if (message.startsWith('Parameters:')) {
          messageElement.className = 'function-params';
        } else if (message.startsWith('API Response:')) {
          messageElement.className = 'api-response';
        } else if (message.startsWith('Gemini:')) {
          messageElement.className = 'gemini-message';
        } else if (message.startsWith('You:')) {
          messageElement.className = 'user-message';
        }
        messageElement.textContent = message;
        handled = true;
      }

      else if (typeof message == 'object' && message !== null) {
        if (message.type === 'tool_call') {
          messageElement.className = 'function-name';
          messageElement.textContent = `Function: ${message.data.name}`;

          const paramsElement = document.createElement('p');
          paramsElement.className = 'function-params';
          paramsElement.textContent = `Parameters: ${JSON.stringify(message.data.args, null, 2)}`;
          output.appendChild(messageElement);
          output.appendChild(paramsElement);
          handled = true;
        }
        else if (message.type === 'tool_result') {
          messageElement.className = 'api-response';
          if (message.data.markdown) {
            const cleanHTML = DOMPurify.sanitize(marked.parse(message.data.markdown));
            messageElement.innerHTML = cleanHTML;
          }
          else {
            messageElement.textContent = `API Response: ${JSON.stringify(message.data, null, 2)}`;
          }

          output.appendChild(messageElement)
          handled = true;
        }
      }

      // handling for markdown and images
      else if (message.type == 'markdown') {
        messageElement.className = 'gemini-message';
        const cleanHTML = DOMPurify.sanitize(marked.parse(message.data));
        messageElement.innerHTML = cleanHTML;
        handled = true;
      }

      else if (message.type === 'image') {
        messageElement.className = 'gemini-message';
        const img = document.createElement('img');
        img.src = message.data
        img.alt = 'Image from Gemini';
        img.style.maxWidth = '100%';
        messageElement.appendChild(img);
        handled = true;
      }

      else if (message.type === 'text') {
        messageElement.className = 'gemini-message';
        messageElement.textContent = message.data;
        handled = true;
      }

      if (!handled) {
        messageElement.textContent = JSON.stringify(message);
      }
      
      // messageElement.textContent = message;
      output.appendChild(messageElement);
      output.scrollTop = output.scrollHeight;
    }

    api.logMessage = logMessage;

    // Add function to send text message
    function sendTextMessage() {
      const textInput = document.getElementById('textInput');
      const text = textInput.value.trim();
      if (!text) return;

      // Clear input
      textInput.value = '';

      // Log user message
      logMessage('You: ' + text);

      // Send text message
      api.sendTextMessage(text);
    }

    // Set up button click handlers
    document.getElementById('micButton').onclick = () => {
      if (isRecording) {
        stopRecording();
      } else {
        startRecording();
      }
    };

    // Add send button handler
    document.getElementById('sendButton').onclick = sendTextMessage;

    // Add keypress handler for text input
    document.getElementById('textInput').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        sendTextMessage();
      }
    });

    document.getElementById('webcamButton').onclick = async () => {
      if (mediaHandler.isWebcamActive) {
        mediaHandler.stopAll();
        document.getElementById('webcamButton').innerHTML = 
          '<span class="material-symbols-outlined">videocam</span>';
      } else {
        const success = await mediaHandler.startWebcam();
        if (success) {
          document.getElementById('webcamButton').innerHTML = 
            '<span class="material-symbols-outlined">videocam_off</span>';
          mediaHandler.startFrameCapture((base64Image) => {
            api.sendImage(base64Image);
          });
        }
      }
    };

    document.getElementById('screenButton').onclick = async () => {
      if (mediaHandler.isScreenActive) {
        mediaHandler.stopAll();
        document.getElementById('screenButton').innerHTML = 
          '<span class="material-symbols-outlined">present_to_all</span>';
      } else {
        const success = await mediaHandler.startScreenShare();
        if (success) {
          document.getElementById('screenButton').innerHTML = 
            '<span class="material-symbols-outlined">cancel_presentation</span>';
          mediaHandler.startFrameCapture((base64Image) => {
            api.sendImage(base64Image);
          });
        }
      }
    };

    // Image Upload Handler
    document.getElementById('imageButton').onclick = () => {
        document.getElementById('imageInput').click(); // Trigger file input
    };

    document.getElementById('imageInput').onchange = (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const base64Image = e.target.result.split(',')[1]; // Remove data URL prefix

                // Display image preview (optional)
                const imagePreview = document.getElementById('imagePreview');
                imagePreview.src = e.target.result;
                document.getElementById('imagePreviewContainer').style.display = 'block';

                api.sendImage(base64Image);
                logMessage('You: Sent an image.');
            };
            reader.readAsDataURL(file);
        }
    };

    // === ADD END SESSION BUTTON HANDLER ===
    document.getElementById('endSessionButton').onclick = () => {
      logMessage("System: Requesting to end session...");
      api.sendEndSessionMessage(); // Call the new API method (needs to be added in gemini-api.js)

      // Disable controls immediately for better UX
      document.getElementById('micButton').disabled = true;
      document.getElementById('webcamButton').disabled = true;
      document.getElementById('screenButton').disabled = true;
      document.getElementById('imageButton').disabled = true;
      document.getElementById('sendButton').disabled = true;
      document.getElementById('textInput').disabled = true;
      document.getElementById('endSessionButton').disabled = true;
      document.getElementById('interruptButton').style.display = 'none';

      if (isRecording) {
          stopRecording(false); // Stop recording without sending 'end' message
      }
      mediaHandler.stopAll(); // Stop media streams
      // The actual disconnect and UI update will happen via api.onClose
    };

    // Add CSS for interrupted message
    const style = document.createElement('style');
    style.textContent = `
      .interrupted-message {
        color: #ff6b6b;
        font-style: italic;
        margin: 4px 0;
        padding: 4px 8px;
        border-left: 3px solid #ff6b6b;
        background-color: rgba(255, 107, 107, 0.1);
      }
    `;
    document.head.appendChild(style);
  </script>
  <script>
    fetch('dyson_home.html')
      .then(response => response.text())
      .then(html => {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const dysonBody = doc.body.innerHTML;
        document.getElementById('dyson-home').innerHTML = dysonBody;
      })
      .catch(err => {
        document.getElementById('dyson-home').innerHTML = '<p style="color:red;">Failed to load Dyson content.</p>';
        console.error('Error loading Dyson content:', err);
      });
  </script>
</body>
</html>